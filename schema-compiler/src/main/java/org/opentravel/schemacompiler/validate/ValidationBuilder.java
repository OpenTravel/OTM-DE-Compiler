/**
 * Copyright (C) 2014 OpenTravel Alliance (info@opentravel.org)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.opentravel.schemacompiler.validate;

import java.math.BigDecimal;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Pattern;

import org.opentravel.schemacompiler.validate.impl.IdentityResolver;

/**
 * Builder used to perform the most basic validation tasks. Sub-classes may extend this builder to
 * incorporate additional validation functions. When new methods are added, it is recommended that
 * the builder pattern is followed to ensure easy usage and code readability within the
 * <code>Validator</code> classes.
 * 
 * @author S. Livezey
 */
public abstract class ValidationBuilder<T extends ValidationBuilder<T>> {

    public static final String ERROR_NULL_VALUE = "NULL_VALUE";
    public static final String ERROR_NULL_OR_BLANK = "NULL_OR_BLANK";
    public static final String ERROR_MUST_BE_EQUAL = "MUST_BE_EQUAL";
    public static final String ERROR_MUST_BE_NULL = "MUST_BE_NULL";
    public static final String ERROR_MUST_BE_NULL_OR_BLANK = "MUST_BE_NULL_OR_BLANK";
    public static final String ERROR_MUST_BE_NOT_EQUAL = "MUST_BE_NOT_EQUAL";
    public static final String ERROR_MUST_BE_GREATER_THAN = "MUST_BE_GREATER_THAN";
    public static final String ERROR_MUST_BE_GREATER_THAN_OR_EQUAL = "MUST_BE_GREATER_THAN_OR_EQUAL";
    public static final String ERROR_MUST_BE_LESS_THAN = "MUST_BE_LESS_THAN";
    public static final String ERROR_MUST_BE_LESS_THAN_OR_EQUAL = "MUST_BE_LESS_THAN_OR_EQUAL";
    public static final String ERROR_CANNOT_CONTAIN_WHITESPACE = "CANNOT_CONTAIN_WHITESPACE";
    public static final String ERROR_NUMERIC_CHARACTERS_ONLY = "NUMERIC_CHARACTERS_ONLY";
    public static final String ERROR_UNDER_MINIMUM_LENGTH = "UNDER_MINIMUM_LENGTH";
    public static final String ERROR_EXCEEDS_MAXIMUM_LENGTH = "EXCEEDS_MAXIMUM_LENGTH";
    public static final String ERROR_NOT_EXACT_LENGTH = "NOT_EXACT_LENGTH";
    public static final String ERROR_PATTERN_MISMATCH = "PATTERN_MISMATCH";
    public static final String ERROR_MUST_START_WITH_UPPERCASE = "MUST_START_WITH_UPPERCASE";
    public static final String ERROR_MUST_START_WITH_LOWERCASE = "MUST_START_WITH_LOWERCASE";
    public static final String ERROR_UNDER_MINIMUM_SIZE = "UNDER_MINIMUM_SIZE";
    public static final String ERROR_EXCEEDS_MAXIMUM_SIZE = "EXCEEDS_MAXIMUM_SIZE";
    public static final String ERROR_NOT_EXACT_SIZE = "NOT_EXACT_SIZE";
    public static final String ERROR_CONTAINS_NULL_ELEMENTS = "CONTAINS_NULL_ELEMENTS";
    public static final String ERROR_DUPLICATE_ELEMENT = "DUPLICATE_ELEMENT";
    public static final String ERROR_MUST_BE_BEFORE = "MUST_BE_BEFORE";
    public static final String ERROR_MUST_BE_ON_OR_BEFORE = "MUST_BE_ON_OR_BEFORE";
    public static final String ERROR_MUST_BE_AFTER = "MUST_BE_AFTER";
    public static final String ERROR_MUST_BE_ON_OR_AFTER = "MUST_BE_ON_OR_AFTER";

    private static final Map<Integer, DateFormat> dateFormats;
    private static Map<String, Pattern> regexCache = new HashMap<String, Pattern>();

    protected Validatable targetObject;
    protected Object propertyValue;
    private String propertyName;
    private String messagePrefix;
    private double multiplierForDecimalComparisons = Math.pow(10, 2);
    private int calendarUnitsForDateComparisons = Calendar.DAY_OF_YEAR;
    private FindingType findingType = FindingType.ERROR;
    private ValidationFindings findings = new ValidationFindings();

    /**
     * Default constructor.
     */
    public ValidationBuilder() {
        this("");
    }

    /**
     * Constructor that assigns a pefix that will be pre-pended to each finding message key
     * generated by this builder.
     * 
     * @param prefix
     *            the prefix string to append
     */
    public ValidationBuilder(String messagePrefix) {
        if ((messagePrefix == null) || (messagePrefix.length() == 0)) {
            this.messagePrefix = "";
        } else {
            if (messagePrefix.endsWith(".")) {
                this.messagePrefix = messagePrefix;
            } else {
                this.messagePrefix = messagePrefix + '.';
            }
        }
    }

    /**
     * Abstract class that returns the generic reference to this object. This approach allows the
     * parent builder class to cast its return types to that of the child class, thus keeping the
     * builder pattern intact.
     * 
     * @return T
     */
    protected abstract T getThis();

    /**
     * Assigns the target object instance to be validated. When a new target object is assigned, the
     * current property name and value for this builder is cleared.
     * 
     * @param targetObject
     *            the target object to be validated
     * @return T
     */
    public T setTargetObject(Validatable targetObject) {
        if (this.targetObject != targetObject) {
            this.targetObject = targetObject;
            this.propertyName = null;
            this.propertyValue = null;
        }
        return getThis();
    }

    /**
     * Assigns the property value (presumed to be from the target object) to be validated.
     * 
     * @param propertyName
     *            the name of the property
     * @param propertyValue
     *            the value of the property
     * @return T
     */
    public T setProperty(String propertyName, Object propertyValue) {
        this.propertyName = propertyName;
        this.propertyValue = propertyValue;
        return getThis();
    }

    /**
     * Specifies the type of finding(s) to add when an assertion fails. The default type of finding
     * is <code>ERROR</code>.
     * 
     * @param findingType
     *            the finding type to assign
     * @return T
     */
    public T setFindingType(FindingType findingType) {
        this.findingType = findingType;
        return getThis();
    }

    /**
     * Specifies the number of decimal digits to examine during floating-point numeric comparisons
     * and assertions. The default comparison unit is two decimal digits.
     * 
     * @param significantDigitsForDecimalComparisons
     *            the number of significant digits to assign
     */
    public void setSignificantDigitsForDecimalComparisons(int significantDigitsForDecimalComparisons) {
        if (significantDigitsForDecimalComparisons < 0) {
            throw new IllegalArgumentException(
                    "The number of significant digits cannot be less than zero.");
        }
        multiplierForDecimalComparisons = Math.pow(10, significantDigitsForDecimalComparisons);
    }

    /**
     * Specifies the significant unit of time to use during date/time comparisons. Valid values for
     * this method include:
     * <ul>
     * <li>{@link Calendar#YEAR}</li>
     * <li>{@link Calendar#MONTH}</li>
     * <li>{@link Calendar#DAY_OF_YEAR}</li>
     * <li>{@link Calendar#HOUR}</li>
     * <li>{@link Calendar#MINUTE}</li>
     * <li>{@link Calendar#SECOND}</li>
     * <li>{@link Calendar#MILLISECOND}</li>
     * </ul>
     * 
     * <p>
     * The default comparison unit is <code>DAY_OF_YEAR</code>.
     * 
     * @param calendarUnitsForDateComparisons
     *            the unit of calendar time to assign
     */
    public void setCalendarUnitsForDateComparisons(int calendarUnitsForDateComparisons) {
        if (!dateFormats.containsKey(calendarUnitsForDateComparisons)) {
            throw new IllegalArgumentException("Invalid calendar unit for date comparisons.");
        }
        this.calendarUnitsForDateComparisons = calendarUnitsForDateComparisons;
    }

    /**
     * Returns the validation findings that have been constructed from the checks performed since
     * this <code>ValidationBuilder</code> was initialized. If no findings have been discovered,
     * this method will return a null value.
     * 
     * @return ValidationFindings
     */
    public ValidationFindings getFindings() {
        ValidationFindings result = new ValidationFindings();

        if (findings.hasFinding()) {
            result.addAll(findings);
        }
        return result;
    }

    /**
     * Allows validators to manually add findings that were discovered during validation checks
     * performed outside of this builder's organic validation methods.
     * 
     * @param findingType
     *            the type of finding to add
     * @param propertyName
     *            the name of the property to which the finding applies
     * @param code
     *            the finding code to use when constructing the message key
     * @param messageParams
     *            the error message parameters
     * @return T
     */
    public T addFinding(FindingType findingType, String propertyName, String code,
            Object... messageParams) {
        StringBuilder messageKey = new StringBuilder(messagePrefix);

        if (targetObject != null) {
            messageKey.append(targetObject.getClass().getSimpleName()).append('.');
        }
        if (propertyName != null) {
            messageKey.append(propertyName).append('.');
        }
        messageKey.append(code);
        findings.addFinding(findingType, targetObject, messageKey.toString(), messageParams);
        return getThis();
    }

    /**
     * Adds all of the findings in the given collection to the list being compiled by this buider.
     * 
     * @param findings
     *            the validation findings to add
     * @return T
     */
    public T addFindings(ValidationFindings findings) {
        this.findings.addAll(findings);
        return getThis();
    }

    /**
     * Adds a finding to the current list.
     * 
     * @param code
     *            the finding code to use when constructing the message key
     * @param messageParams
     *            the error message parameters
     */
    protected void addFinding(String code, Object... messageParams) {
        addFinding(findingType, propertyName, code, messageParams);
    }

    /**
     * Returns true if no findings have been discovered by this builder.
     * 
     * @return boolean
     */
    public boolean isEmpty() {
        return findings.isEmpty();
    }

    /**
     * Adds a validation finding if the current property value is not null.
     * 
     * @return T
     */
    public T assertNull() {
        if (propertyValue != null) {
            addFinding(ERROR_MUST_BE_NULL);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property (trimmed) string value is neither null nor
     * blank.
     * 
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a string
     */
    public T assertNullOrBlank() {
        String value = propertyValueAsString();

        if ((value != null) && !value.trim().equals("")) {
            addFinding(ERROR_MUST_BE_NULL_OR_BLANK);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property value is null.
     * 
     * @return T
     */
    public T assertNotNull() {
        if (propertyValue == null) {
            addFinding(ERROR_NULL_VALUE);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property (trimmed) string value is null or blank.
     * 
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a string
     */
    public T assertNotNullOrBlank() {
        String value = propertyValueAsString();

        if ((value == null) || (value.trim().equals(""))) {
            addFinding(ERROR_NULL_OR_BLANK);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is not greater than the specified limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertGreaterThan(long limit) {
        long value = propertyValueAsLong();

        if (value <= limit) {
            addFinding(ERROR_MUST_BE_GREATER_THAN, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is not greater than the specified limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertGreaterThan(double limit) {
        double value = propertyValueAsDouble();

        if (roundDouble(value) <= roundDouble(limit)) {
            addFinding(ERROR_MUST_BE_GREATER_THAN, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is not greater than or equal to the
     * specified limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertGreaterThanOrEqual(long limit) {
        long value = propertyValueAsLong();

        if (value < limit) {
            addFinding(ERROR_MUST_BE_GREATER_THAN_OR_EQUAL, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is not greater than or equal to the
     * specified limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertGreaterThanOrEqual(double limit) {
        double value = propertyValueAsDouble();

        if (roundDouble(value) < roundDouble(limit)) {
            addFinding(ERROR_MUST_BE_GREATER_THAN_OR_EQUAL, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is not less than the specified limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertLessThan(long limit) {
        long value = propertyValueAsLong();

        if (value >= limit) {
            addFinding(ERROR_MUST_BE_LESS_THAN, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is not less than the specified limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertLessThan(double limit) {
        double value = propertyValueAsDouble();

        if (roundDouble(value) >= roundDouble(limit)) {
            addFinding(ERROR_MUST_BE_LESS_THAN, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is not less than or equal to the specified
     * limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertLessThanOrEqual(long limit) {
        long value = propertyValueAsLong();

        if (value > limit) {
            addFinding(ERROR_MUST_BE_LESS_THAN_OR_EQUAL, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is not less than or equal to the specified
     * limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertLessThanOrEqual(double limit) {
        double value = propertyValueAsDouble();

        if (roundDouble(value) > roundDouble(limit)) {
            addFinding(ERROR_MUST_BE_LESS_THAN_OR_EQUAL, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is not equal to the specified limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertEquals(long limit) {
        long value = propertyValueAsLong();

        if (value != limit) {
            addFinding(ERROR_MUST_BE_EQUAL, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is not equal to the specified limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertEquals(double limit) {
        double value = propertyValueAsDouble();

        if (roundDouble(value) != roundDouble(limit)) {
            addFinding(ERROR_MUST_BE_EQUAL, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is not equal to the specified limit.
     * 
     * @param obj
     *            the comparison object for the value
     * @return T
     */
    public T assertEquals(Object obj) {
        if (isFloatingPointNumber(propertyValue) && isFloatingPointNumber(obj)) {
            assertEquals(((Number) obj).doubleValue());

        } else if (isIntegerNumber(propertyValue) && isIntegerNumber(obj)) {
            assertEquals(((Number) obj).longValue());

        } else if ((propertyValue == null) ? (obj != null) : !propertyValue.equals(obj)) {
            addFinding(ERROR_MUST_BE_EQUAL, propertyValue, obj);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is equal to the specified limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertNotEqual(long limit) {
        long value = propertyValueAsLong();

        if (value == limit) {
            addFinding(ERROR_MUST_BE_NOT_EQUAL, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is equal to the specified limit.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    public T assertNotEqual(double limit) {
        double value = propertyValueAsDouble();

        if (roundDouble(value) == roundDouble(limit)) {
            addFinding(ERROR_MUST_BE_NOT_EQUAL, value, limit);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the current property is equal to the specified limit.
     * 
     * @param obj
     *            the comparison object for the value
     * @return T
     */
    public T assertNotEqual(Object obj) {
        if (isFloatingPointNumber(propertyValue) && isFloatingPointNumber(obj)) {
            assertNotEqual(((Number) obj).doubleValue());

        } else if (isIntegerNumber(propertyValue) && isIntegerNumber(obj)) {
            assertNotEqual(((Number) obj).longValue());

        } else if ((propertyValue == null) ? (obj == null) : propertyValue.equals(obj)) {
            addFinding(ERROR_MUST_BE_NOT_EQUAL, propertyValue, obj);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the string value contains any whitespace characters.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a string
     */
    public T assertContainsNoWhitespace() {
        String value = propertyValueAsString();
        char[] ch = (value != null) ? value.toCharArray() : new char[0];
        boolean hasWhitespace = false;

        for (int i = 0; !hasWhitespace && (i < ch.length); i++) {
            hasWhitespace = Character.isWhitespace(ch[i]);
        }
        if (hasWhitespace) {
            addFinding(ERROR_CANNOT_CONTAIN_WHITESPACE, value);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the string value contains one or more non-numeric characters.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a string
     */
    public T assertContainsOnlyNumericCharacters() {
        String value = propertyValueAsString();
        char[] ch = (value != null) ? value.toCharArray() : new char[0];
        boolean hasNonNumeric = false;

        for (int i = 0; !hasNonNumeric && (i < ch.length); i++) {
            hasNonNumeric = !Character.isDigit(ch[i]);
        }
        if (hasNonNumeric) {
            addFinding(ERROR_NUMERIC_CHARACTERS_ONLY, value);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the string value contains fewer characters than the specified
     * minimum length.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param minLength
     *            the minimum length of the string
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a string
     */
    public T assertMinimumLength(int minLength) {
        String value = propertyValueAsString();

        if ((value != null) && (value.length() < minLength)) {
            addFinding(ERROR_UNDER_MINIMUM_LENGTH, value, minLength);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the string value is longer than the specified maximum length.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param maxLength
     *            the maximum length of the string
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a string
     */
    public T assertMaximumLength(int maxLength) {
        String value = propertyValueAsString();

        if ((value != null) && (value.length() > maxLength)) {
            addFinding(ERROR_EXCEEDS_MAXIMUM_LENGTH, value, maxLength);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the string value does not contain the exact number of characters
     * specified.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param exactLength
     *            the expected exact length of the string
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a string
     */
    public T assertExactLength(int exactLength) {
        String value = propertyValueAsString();

        if ((value != null) && (value.length() != exactLength)) {
            addFinding(ERROR_NOT_EXACT_LENGTH, value, exactLength);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the string values does not match the regular expression
     * provided.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param regex
     *            the regular expression pattern to match
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a string
     */
    public T assertPatternMatch(String regex) {
        String value = propertyValueAsString();
        Pattern pattern = getPattern(regex);

        if ((value != null) && !pattern.matcher(value).matches()) {
            addFinding(ERROR_PATTERN_MISMATCH, value, regex);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the string value does not start with an upper-case letter.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a string
     */
    public T assertStartsWithUppercaseLetter() {
        String value = propertyValueAsString();

        if ((value != null) && (value.length() >= 1)) {
            char firstChar = value.charAt(0);

            if (!Character.isLetter(firstChar) || !Character.isUpperCase(firstChar)) {
                addFinding(ERROR_MUST_START_WITH_UPPERCASE, value);
            }
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the string value does not start with an lower-case letter.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a string
     */
    public T assertStartsWithLowercaseLetter() {
        String value = propertyValueAsString();

        if ((value != null) && (value.length() >= 1)) {
            char firstChar = value.charAt(0);

            if (!Character.isLetter(firstChar) || !Character.isLowerCase(firstChar)) {
                addFinding(ERROR_MUST_START_WITH_LOWERCASE, value);
            }
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the collection value contains fewer elements than the specified
     * minimum size.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param minSize
     *            the minimum size of the collection
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a collection
     */
    public T assertMinimumSize(int minSize) {
        Collection<?> value = propertyValueAsCollection();

        if ((value != null) && (value.size() < minSize)) {
            addFinding(ERROR_UNDER_MINIMUM_SIZE, value.size(), minSize);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the collection value contains more elements than the specified
     * maximum size.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param maxSize
     *            the maximum size of the collection
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a collection
     */
    public T assertMaximumSize(int maxSize) {
        Collection<?> value = propertyValueAsCollection();

        if ((value != null) && (value.size() > maxSize)) {
            addFinding(ERROR_EXCEEDS_MAXIMUM_SIZE, value.size(), maxSize);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the collection value does not contain the exact number of
     * elements specified.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param exactSize
     *            the expected exact length of the collection
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a collection
     */
    public T assertExactSize(int exactSize) {
        Collection<?> value = propertyValueAsCollection();

        if ((value != null) && (value.size() != exactSize)) {
            addFinding(ERROR_NOT_EXACT_SIZE, value.size(), exactSize);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the collection value contains one or more null elements.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a collection
     */
    public T assertContainsNoNullElements() {
        Collection<?> value = propertyValueAsCollection();

        if (value != null) {
            boolean nullFound = false;

            for (Object obj : value) {
                if (obj == null) {
                    nullFound = true;
                    break;
                }
            }
            if (nullFound) {
                addFinding(ERROR_CONTAINS_NULL_ELEMENTS);
            }
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the collection property value contains one or more elements that
     * share the same name as that of the current target object. Duplicity is determined by
     * comparing the identity names of each member element as determined by the identity resolver
     * instance provided.
     * 
     * <p>
     * NOTE: The collection property value is expected to contain a copy of the current target
     * value, so there is no need to exclude it from the collection that assigned as the current
     * property value.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param identityResolver
     *            used to identify the identity names for members of the current collection value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a collection
     */
    @SuppressWarnings("unchecked")
    public <E> T assertNoDuplicates(IdentityResolver<E> identityResolver) {
        try {
            Collection<E> siblingMembers = (Collection<E>) propertyValueAsCollection();
            String targetIdentity = identityResolver.getIdentity((E) targetObject);

            if (targetIdentity != null) {
                for (E member : siblingMembers) {
                    if (member == targetObject) {
                        continue;
                    }
                    if (targetIdentity.equals(identityResolver.getIdentity(member))) {
                        addFinding(ERROR_DUPLICATE_ELEMENT, targetIdentity);
                        break;
                    }
                }
            }
        } catch (ClassCastException e) {
            throw new IllegalArgumentException(
                    "Unexpected exception during duplicate element validation.", e);
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the date value occurs on or after the date limit value provided.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a date value
     */
    public T assertBefore(Date limit) {
        Date value = propertyValueAsDate();

        if ((value != null) && (limit != null)) {
            Date _value = roundDate(value);
            Date _limit = roundDate(limit);

            if (!_value.before(_limit)) {
                addFinding(ERROR_MUST_BE_BEFORE, value, limit);
            }
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the date value occurs after the date limit value provided.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a date value
     */
    public T assertOnOrBefore(Date limit) {
        Date value = propertyValueAsDate();

        if ((value != null) && (limit != null)) {
            Date _value = roundDate(value);
            Date _limit = roundDate(limit);

            if (_value.after(_limit)) {
                addFinding(ERROR_MUST_BE_ON_OR_BEFORE, value, limit);
            }
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the date value occurs on or before the date limit value
     * provided.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a date value
     */
    public T assertAfter(Date limit) {
        Date value = propertyValueAsDate();

        if ((value != null) && (limit != null)) {
            Date _value = roundDate(value);
            Date _limit = roundDate(limit);

            if (!_value.after(_limit)) {
                addFinding(ERROR_MUST_BE_AFTER, value, limit);
            }
        }
        return getThis();
    }

    /**
     * Adds a validation finding if the date value occurs on or after the date limit value provided.
     * 
     * <p>
     * Null values checked by this method <i>will not</i> produce an error.
     * 
     * @param limit
     *            the comparison limit for the value
     * @return T
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a date value
     */
    public T assertOnOrAfter(Date limit) {
        Date value = propertyValueAsDate();

        if ((value != null) && (limit != null)) {
            Date _value = roundDate(value);
            Date _limit = roundDate(limit);

            if (_value.before(_limit)) {
                addFinding(ERROR_MUST_BE_ON_OR_AFTER, value, limit);
            }
        }
        return getThis();
    }

    /**
     * Returns the current property value as a string object.
     * 
     * @return String
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a string
     */
    protected String propertyValueAsString() {
        if ((propertyValue == null) || (propertyValue instanceof String)) {
            return (String) propertyValue;
        } else {
            throw new IllegalArgumentException(
                    "The requested assertion only applies to string values.");
        }
    }

    /**
     * Returns the current property value as a long integer.
     * 
     * @return long
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    protected long propertyValueAsLong() {
    	long theValue;
    	
        if (propertyValue == null) {
        	theValue = 0L;
        	
        } else if (propertyValue instanceof Number) {
            theValue = ((Number) propertyValue).longValue();
            
        } else {
            throw new IllegalArgumentException(
                    "The requested assertion only applies to numeric values.");
        }
        return theValue;
    }

    /**
     * Returns the current property value as a floating-point value.
     * 
     * @return double
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a numeric value
     */
    protected double propertyValueAsDouble() {
    	double theValue;
    	
        if (propertyValue == null) {
        	theValue = 0.0D;
        	
        } else if (propertyValue instanceof Number) {
            theValue = ((Number) propertyValue).doubleValue();
            
        } else {
            throw new IllegalArgumentException(
                    "The requested assertion only applies to numeric values.");
        }
        return theValue;
    }

    /**
     * Returns the current property value as a collection object.
     * 
     * @return Collection<?>
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a date value
     */
    protected Collection<?> propertyValueAsCollection() {
        if ((propertyValue == null) || (propertyValue instanceof Collection)) {
            return (Collection<?>) propertyValue;
        } else {
            throw new IllegalArgumentException(
                    "The requested assertion only applies to collection values.");
        }
    }

    /**
     * Returns the current property value as a date object.
     * 
     * @return java.util.Date
     * @throws IllegalArgumentException
     *             thrown if the current property value is not a date value
     */
    protected Date propertyValueAsDate() {
        if ((propertyValue == null) || (propertyValue instanceof Date)) {
            return (Date) propertyValue;
        } else {
            throw new IllegalArgumentException(
                    "The requested assertion only applies to date values.");
        }
    }

    /**
     * Returns true if the given object represents a boxed floating-point numeric type.
     * 
     * @param obj
     *            the object to inspect
     * @return boolean
     */
    protected boolean isFloatingPointNumber(Object obj) {
        return (obj instanceof Double) || (obj instanceof Float) || (obj instanceof BigDecimal);
    }

    /**
     * Returns true if the given object represents a boxed floating-point numeric type.
     * 
     * @param obj
     *            the object to inspect
     * @return boolean
     */
    protected boolean isIntegerNumber(Object obj) {
        return (obj instanceof Number) && !isFloatingPointNumber(obj);
    }

    /**
     * Rounds the given double value to the nearest significant decimal place. The unit of measure
     * assigned by the {@link #setSignificantDigitsForDecimalComparisons(int)} is used to determine
     * the significant timeframe for the comparison.
     * 
     * @param a_double
     *            the floating-point value to round
     * @return double
     */
    protected double roundDouble(double a_double) {
        return ((double) Math.round(a_double * multiplierForDecimalComparisons))
                / multiplierForDecimalComparisons;
    }

    /**
     * Rounds dates to the nearest indicated significant unit for comparison purposes. The unit of
     * measure assigned by the {@link #setCalendarUnitsForDateComparisons(int)} is used to determine
     * the significant timeframe for the comparison.
     * 
     * @param a_date
     *            the date value to round
     * @return java.util.Date
     */
    protected Date roundDate(Date a_date) {
        Date result = a_date;
        try {
            DateFormat df = dateFormats.get(calendarUnitsForDateComparisons);

            if (df != null) {
                result = df.parse(df.format(a_date));
            }
        } catch (Throwable t) {
            // No error - return the original value
        }
        return result;
    }

    /**
     * Returns a <code>Pattern</code> using the regular expression provided. Patterns are cached to
     * improve performance.
     * 
     * @param regex
     *            the regular expression string
     * @return java.util.regex.Pattern
     */
    protected Pattern getPattern(String regex) {
        synchronized (regexCache) {
            Pattern pattern = regexCache.get(regex);

            if (pattern == null) {
                pattern = Pattern.compile(regex);
                regexCache.put(regex, pattern);
            }
            return pattern;
        }
    }

    /**
     * Initializes the date formats used for rounding during comparisons.
     */
    static {
        try {
            Map<Integer, DateFormat> formats = new HashMap<Integer, DateFormat>();

            formats.put(Calendar.YEAR, new SimpleDateFormat("yyyy"));
            formats.put(Calendar.MONTH, new SimpleDateFormat("yyyy.MM"));
            formats.put(Calendar.DAY_OF_YEAR, new SimpleDateFormat("yyyy.MM.dd"));
            formats.put(Calendar.HOUR, new SimpleDateFormat("yyyy.MM.dd HH"));
            formats.put(Calendar.MINUTE, new SimpleDateFormat("yyyy.MM.dd HH:mm"));
            formats.put(Calendar.SECOND, new SimpleDateFormat("yyyy.MM.dd HH:mm:ss"));
            formats.put(Calendar.MILLISECOND, new SimpleDateFormat("yyyy.MM.dd HH:mm:ss SSS"));
            dateFormats = Collections.unmodifiableMap(formats);

        } catch (Throwable t) {
            throw new ExceptionInInitializerError(t);
        }
    }

}
